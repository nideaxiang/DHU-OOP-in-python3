# 第九讲 面向对象的程序设计

### 类：一种数据结构，包含数据成员本身和其函数

### 面向对象程序设计具有3个基本特征：封装、继承和多态

## 1基本概念

### 1.1 封装：讲数据成员、属性、方法和事件集合在一个整体内

### 	——保证了对象的独立性

### 1.2 继承：对现有类进行扩展

### 1.3 多态性：



## 2类对象和实例对象：实例是对象的具体实体

类称为类对象，类的实例称为实例对象

### 2.1 类对象

~~~python
##声明
class 类名：
	类体
~~~

类名：每个单词第一个字母需要大写

类体：该类的属性和操作

### 2.2 实例对象

创建类的对象=实例化类=创建类的实例

调用示例

~~~python
obj=类名(参数列表)
obj.对象函数 / obj.对象属性 
#使用  类.函数/属性 进行对类成员的调用 
~~~



## 3 属性：在类中定义的描述类特征的值

类定义时，一般需要进行类属性的初始化

~~~python
class Pe:
    def __init__(self,name,age):
        self.name='a'
        self.age='18'
~~~

### 3.1 实例对象属性：self.变量名 

~~~python
#内部访问：
self.实例变量名=值
#外部访问：
obj.实例变量名=值
~~~

### 3.2 类对象属性

~~~python
#初始化
类变量=初始值
#不论内外访问
类名.变量名=值
~~~



### 3.3 私有属性和公有属性

~~~python
#私有属性
class a:
    __name="classa"
    #在方法中访问
    def getname():
        print(a.__name)
~~~

不能直接访问私有属性，但可以在方法中访问

  

### 3.4 @property装饰器：解决了对私有属性的访问

定义私有属性——定义相应的访问函数——使用@property装饰——把函数当作属性进行访问

~~~python
@property
def name(self):
	return self.__name
p=a('王五')
print(a.name)
>>> 王五
~~~

### 3.5 特殊属性：以双下划线开始和结束

![image-20240418134000500](C:\Users\ASUS\Desktop\assets\image-20240418134000500.png)



### 3.6 自定义属性

在类定义中不存在的属性。对象可以通过特殊属性`__dict__`进行存储自定义的属性

~~~python
#自定义属性
a.age='18'  #age 为定义a时不存在的属性
a.__dict__
>>>{'name':'王五','age':'18'}
~~~

### 3.7 魔法函数

#### 1、__getattr__魔法函数

作用：当调用的对象的属性不存在的时候会触发__getattr__魔法函数，此时可以在此魔法函数做一些定制化处理

~~~python
class Student2(object):
    def __init__(self, name):
        self.name = name

    def __getattr__(self,item):
        print("no {attr} exist...".format(attr=item))
        return 0

s = Student2("Jack")
print(s.name)
print(s.age)   # 不存在的属性

>>>
Jack
no age exist...
0

~~~



 ## 4 方法

类方法的定义与普通的函数定义一致

### 一般情况下，类方法的第一个参数为self，这种方法称为对象实例方法，在调用该方法时，python会自动把对象实例传递给该参数



### 4.1 静态方法：与对象实例无关的方法，不对实例进行操作，仅仅调用方法本身

~~~python
@staticmethod
def 静态函数方法名（[形参列表]）: #没有self
    函数名
~~~

### 4.2 类方法：类本身的方法，不对特定的实例进行操作

如果在类方法中访问对象实例属性，则会报错

~~~python
#声明类方法
@classmethod
def 类方法名(cls,[形参]):
    函数体
    
    
class fo():
    classname='fo'
    @classmethod
    def f(cls):
        print(cls.classname)

fo.f()
>>> fo
~~~



### 4.3 \__init__()方法、\__new__()方法、\__del\__()

\__new__()是一个类方法，创建对象时调用,返回一个实例

####  \__init__()方法方法：构造函数，在创建完对象后调用，初始化当前对象的实例

#### \__del__()方法：析构方法：摧毁类的实例



### 4.4 私有方法：也是用两个下划线定义



### 4.5 方法重载：在类中定义多个重名的方法，不会报错，但只有最有一个有效







## 5 继承：在一个类的基础上创建另一个类，继承除构造函数外的所以成员

一个派生类可以继承多个基类

~~~python
class 派生类名(基类1，[基类2，...]):
    类体
~~~

注意：

- 在声明派生类时，必须在其构造函数中调用基类的构造函数

- 查看继承关系：

~~~python
A.mro()
A.__MRO__
~~~

- 类成员的继承中的重写

若要在派生类中重新定义基类里的方法，则会实现对基类的覆盖



## 6 对象的特殊方法：双下划线开始和结束的方法

### 6.1 大全



### 6.2  在定义类时，可以实现对特殊方法以及运算符的重载



### 6.3 @functools.total_ordering装饰器

###  6.4 使用\__call__()方法 调用对象



##  7 对象的各种赋值、引用

- 对象的引用：创建一个对象并把它赋值给一个变量，该变量将会指向给对象的引用，id()值一致

​	完全不独立，父对象与子对象均有联系

- 对象的浅拷贝：切片操作、copy、对象实例化

​	父对象实现了复制，父对象对立

- 深拷贝:

​	父对象与子对象均实现了复制，均独立



## 8 可迭代对象：迭代器与生成器函数

##### 实现了\__iter__()就是可迭代对象

- 判断是否为可迭代对象

  ~~~python
  isinstance((1,2,3),collections.abc.Iterable)
  ~~~

- 迭代器：实现\_next()_的对象 如range

- 迭代器协议：next和iter 前者用于返回下一个元素，后者用于返回对象本身



### 8.2 生成器函数使用yield替代return 返回一个值